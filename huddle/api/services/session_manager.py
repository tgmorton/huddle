"""Session manager for active game connections."""

import asyncio
from typing import Optional
from uuid import UUID

from fastapi import WebSocket

from huddle.api.services.game_service import GameService
from huddle.core.models.team import Team
from huddle.events.types import GameEvent


class GameSession:
    """Represents an active game session with WebSocket connection."""

    def __init__(
        self,
        game_id: UUID,
        service: GameService,
        websocket: Optional[WebSocket] = None,
    ) -> None:
        self.game_id = game_id
        self.service = service
        self.websocket = websocket
        self._simulation_task: Optional[asyncio.Task] = None

    async def send_event(self, event: GameEvent) -> None:
        """Send event to connected WebSocket."""
        if self.websocket:
            from huddle.api.schemas.events import WSMessage
            from huddle.events.types import (
                GameEndEvent,
                PlayCompletedEvent,
                QuarterEndEvent,
                ScoringEvent,
                TurnoverEvent,
            )

            # Convert event to appropriate WebSocket message
            if isinstance(event, PlayCompletedEvent):
                message = WSMessage.play_completed(event)
            elif isinstance(event, ScoringEvent):
                message = WSMessage.scoring(event)
            elif isinstance(event, TurnoverEvent):
                message = WSMessage.turnover(event)
            elif isinstance(event, QuarterEndEvent):
                message = WSMessage.quarter_end(event)
            elif isinstance(event, GameEndEvent):
                message = WSMessage.game_end(event)
            else:
                return  # Unknown event type

            try:
                await self.websocket.send_json(message.model_dump(mode="json"))
            except Exception:
                # Connection may be closed
                pass

    def start_simulation(self) -> None:
        """Start the simulation loop as background task."""
        if self._simulation_task is None or self._simulation_task.done():
            self._simulation_task = asyncio.create_task(
                self.service.run_simulation(
                    on_awaiting_play_call=self._on_awaiting_play_call
                )
            )

    def _on_awaiting_play_call(self) -> None:
        """Called when service is waiting for play call."""
        if self.websocket:
            from huddle.api.schemas.events import WSMessage

            message = WSMessage.awaiting_play_call(
                self.service.game_state.down_state,
                list(self.service.get_quick_play_calls().keys()),
            )
            # Schedule the send as a task since we're not in async context
            asyncio.create_task(self._send_message(message))

    async def _send_message(self, message) -> None:
        """Send a message to WebSocket."""
        if self.websocket:
            try:
                await self.websocket.send_json(message.model_dump(mode="json"))
            except Exception:
                pass

    def stop_simulation(self) -> None:
        """Stop the simulation loop."""
        self.service.stop_simulation()
        if self._simulation_task and not self._simulation_task.done():
            self._simulation_task.cancel()


class SessionManager:
    """Manages active game sessions."""

    def __init__(self) -> None:
        self._sessions: dict[UUID, GameSession] = {}

    def create_session(
        self,
        game_id: Optional[UUID],
        home_team: Team,
        away_team: Team,
    ) -> GameSession:
        """Create a new game session."""
        service = GameService(home_team, away_team)
        service.create_game()

        # Use the game's actual ID (generated by GameService) if none provided
        actual_game_id = game_id if game_id else service.game_state.id
        session = GameSession(actual_game_id, service)

        # Set up event callback to push to WebSocket
        def event_callback(event: GameEvent) -> None:
            asyncio.create_task(session.send_event(event))

        service.set_event_callback(event_callback)
        self._sessions[actual_game_id] = session

        return session

    def get_session(self, game_id: UUID) -> Optional[GameSession]:
        """Get an existing session."""
        return self._sessions.get(game_id)

    def remove_session(self, game_id: UUID) -> None:
        """Remove a session."""
        session = self._sessions.pop(game_id, None)
        if session:
            session.stop_simulation()

    def attach_websocket(self, game_id: UUID, websocket: WebSocket) -> Optional[GameSession]:
        """Attach a WebSocket connection to a session."""
        session = self._sessions.get(game_id)
        if session:
            session.websocket = websocket
        return session

    def detach_websocket(self, game_id: UUID) -> None:
        """Detach WebSocket from a session."""
        session = self._sessions.get(game_id)
        if session:
            session.websocket = None

    @property
    def active_sessions(self) -> list[UUID]:
        """Get list of active session IDs."""
        return list(self._sessions.keys())


# Global session manager instance
session_manager = SessionManager()
