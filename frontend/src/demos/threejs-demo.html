<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Football Sim Demo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Berkeley Mono', 'SF Mono', monospace;
      background: #0a0a0a;
      color: #e5e5e5;
      overflow: hidden;
    }
    #canvas-container {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
    }
    .overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
    }
    .header {
      background: rgba(0,0,0,0.8);
      border: 1px solid #333;
      border-radius: 4px;
      padding: 16px;
      margin-bottom: 12px;
    }
    h1 { font-size: 18px; color: #f59e0b; margin-bottom: 8px; }
    .subtitle { color: #888; font-size: 13px; }
    .panel {
      background: rgba(0,0,0,0.8);
      border: 1px solid #333;
      border-radius: 4px;
      padding: 16px;
      margin-bottom: 12px;
      max-width: 280px;
    }
    .panel-title {
      font-size: 12px;
      color: #f59e0b;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
    }
    .camera-btn {
      display: block;
      width: 100%;
      padding: 10px;
      margin-bottom: 8px;
      background: #222;
      border: 1px solid #444;
      color: #e5e5e5;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 13px;
      text-align: left;
    }
    .camera-btn:hover { background: #333; border-color: #f59e0b; }
    .camera-btn.active { background: #f59e0b; color: #000; }
    .camera-btn small { display: block; color: #888; font-size: 11px; margin-top: 2px; }
    .camera-btn.active small { color: #333; }
    .features {
      font-size: 12px;
      line-height: 1.8;
      color: #888;
    }
    .features code {
      background: #222;
      padding: 2px 6px;
      border-radius: 3px;
      color: #f59e0b;
    }
    .info-bar {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      border: 1px solid #333;
      border-radius: 4px;
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      font-size: 13px;
    }
    .stat { color: #888; }
    .stat span { color: #f59e0b; }
    .controls-hint {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 12px;
      color: #888;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="overlay">
    <div class="header">
      <h1>THREE.JS DEMO</h1>
      <div class="subtitle">3D WebGL with camera controls and depth</div>
    </div>

    <div class="panel">
      <div class="panel-title">Camera Presets</div>
      <button class="camera-btn active" data-camera="broadcast">
        Broadcast View
        <small>Classic TV angle</small>
      </button>
      <button class="camera-btn" data-camera="endzone">
        End Zone
        <small>Behind QB perspective</small>
      </button>
      <button class="camera-btn" data-camera="overhead">
        Overhead
        <small>All-22 film view</small>
      </button>
      <button class="camera-btn" data-camera="sideline">
        Sideline
        <small>Coach's view</small>
      </button>
      <button class="camera-btn" data-camera="dynamic">
        Dynamic
        <small>Follows the action</small>
      </button>
    </div>

    <div class="panel">
      <div class="panel-title">Three.js Features</div>
      <ul class="features">
        <li><code>OrbitControls</code> - pan/zoom/rotate</li>
        <li><code>PerspectiveCamera</code> - depth perception</li>
        <li>3D player models possible</li>
        <li>Shadows and lighting</li>
        <li>Ball trajectory arcs</li>
        <li>Stadium environments</li>
        <li>Particle effects (rain/snow)</li>
        <li>Post-processing (bloom, DOF)</li>
      </ul>
    </div>
  </div>

  <div class="controls-hint">
    Drag to rotate | Scroll to zoom | Right-drag to pan
  </div>

  <div class="info-bar">
    <div class="stat">Time: <span id="time">0.0s</span></div>
    <div class="stat">Down: <span>2nd & 7</span></div>
    <div class="stat">Ball On: <span>OPP 35</span></div>
    <div class="stat">Score: <span>HOME 14 - AWAY 10</span></div>
  </div>

  <!-- ES Module imports for modern Three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1628);
    scene.fog = new THREE.Fog(0x0a1628, 80, 200);

    // Camera
    const camera = new THREE.PerspectiveCamera(
      50, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.set(0, 35, 50);
    camera.lookAt(0, 0, 10);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2 - 0.1;
    controls.minDistance = 15;
    controls.maxDistance = 120;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(30, 50, 30);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 10;
    sunLight.shadow.camera.far = 150;
    sunLight.shadow.camera.left = -60;
    sunLight.shadow.camera.right = 60;
    sunLight.shadow.camera.top = 60;
    sunLight.shadow.camera.bottom = -60;
    scene.add(sunLight);

    // Stadium lights
    const stadiumLight1 = new THREE.PointLight(0xffffee, 0.5, 100);
    stadiumLight1.position.set(-30, 40, -20);
    scene.add(stadiumLight1);

    const stadiumLight2 = new THREE.PointLight(0xffffee, 0.5, 100);
    stadiumLight2.position.set(30, 40, -20);
    scene.add(stadiumLight2);

    // Field
    const fieldGeometry = new THREE.PlaneGeometry(53.33, 100);
    const fieldMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a5c2e,
      roughness: 0.8,
    });
    const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
    field.rotation.x = -Math.PI / 2;
    field.receiveShadow = true;
    scene.add(field);

    // Field lines
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });

    // Yard lines
    for (let y = -40; y <= 40; y += 5) {
      const points = [
        new THREE.Vector3(-26.5, 0.01, y),
        new THREE.Vector3(26.5, 0.01, y),
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, y === 0 ?
        new THREE.LineBasicMaterial({ color: 0xffffff }) : lineMaterial);
      scene.add(line);
    }

    // Sidelines
    [-26.5, 26.5].forEach(x => {
      const points = [
        new THREE.Vector3(x, 0.01, -50),
        new THREE.Vector3(x, 0.01, 50),
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, lineMaterial);
      scene.add(line);
    });

    // End zones
    const endZoneGeometry = new THREE.PlaneGeometry(53.33, 10);
    const endZoneMaterial = new THREE.MeshStandardMaterial({
      color: 0x8b0000,
      roughness: 0.8,
    });
    const endZone1 = new THREE.Mesh(endZoneGeometry, endZoneMaterial);
    endZone1.rotation.x = -Math.PI / 2;
    endZone1.position.set(0, 0.001, -55);
    scene.add(endZone1);

    const endZone2Material = new THREE.MeshStandardMaterial({
      color: 0x00008b,
      roughness: 0.8,
    });
    const endZone2 = new THREE.Mesh(endZoneGeometry, endZone2Material);
    endZone2.rotation.x = -Math.PI / 2;
    endZone2.position.set(0, 0.001, 55);
    scene.add(endZone2);

    // Player data
    const playersData = [
      // Offense (gold)
      { id: 'qb', name: 'QB', x: 0, z: -5, team: 'offense', hasBall: true },
      { id: 'wr1', name: 'WR', x: 22, z: 0, team: 'offense', route: [[22, 0], [22, 10], [22, 25]] },
      { id: 'wr2', name: 'WR', x: -20, z: 0, team: 'offense', route: [[-20, 0], [-15, 8], [-8, 12]] },
      { id: 'te', name: 'TE', x: 8, z: -1, team: 'offense', route: [[8, -1], [8, 12], [12, 18]] },
      { id: 'rb', name: 'RB', x: -3, z: -7, team: 'offense' },
      { id: 'lt', name: 'LT', x: -6, z: -1, team: 'offense' },
      { id: 'lg', name: 'LG', x: -3, z: -1, team: 'offense' },
      { id: 'c', name: 'C', x: 0, z: -1, team: 'offense' },
      { id: 'rg', name: 'RG', x: 3, z: -1, team: 'offense' },
      { id: 'rt', name: 'RT', x: 6, z: -1, team: 'offense' },
      // Defense (red)
      { id: 'cb1', name: 'CB', x: 24, z: 7, team: 'defense' },
      { id: 'cb2', name: 'CB', x: -22, z: 7, team: 'defense' },
      { id: 'ss', name: 'SS', x: 5, z: 15, team: 'defense' },
      { id: 'fs', name: 'FS', x: -5, z: 18, team: 'defense' },
      { id: 'mlb', name: 'MLB', x: 0, z: 5, team: 'defense' },
      { id: 'olb1', name: 'OLB', x: -8, z: 4, team: 'defense' },
      { id: 'olb2', name: 'OLB', x: 8, z: 4, team: 'defense' },
      { id: 'de1', name: 'DE', x: -7, z: 1, team: 'defense' },
      { id: 'de2', name: 'DE', x: 7, z: 1, team: 'defense' },
      { id: 'dt1', name: 'DT', x: -2, z: 1, team: 'defense' },
      { id: 'dt2', name: 'DT', x: 2, z: 1, team: 'defense' },
    ];

    const playerMeshes = {};
    const routeLines = [];

    // Create player meshes
    playersData.forEach(p => {
      const isOffense = p.team === 'offense';

      // Player body (capsule-like)
      const bodyGeometry = new THREE.CapsuleGeometry(0.6, 1.2, 8, 16);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: isOffense ? 0xf59e0b : 0xef4444,
        roughness: 0.5,
        metalness: 0.1,
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.castShadow = true;
      body.position.set(p.x, 1.2, p.z);

      // Helmet (sphere on top)
      const helmetGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      const helmetMaterial = new THREE.MeshStandardMaterial({
        color: isOffense ? 0xfbbf24 : 0xf87171,
        roughness: 0.3,
        metalness: 0.2,
      });
      const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
      helmet.position.y = 1.3;
      helmet.castShadow = true;
      body.add(helmet);

      // Direction indicator (small cone)
      const coneGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
      const coneMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        opacity: 0.7,
        transparent: true,
      });
      const cone = new THREE.Mesh(coneGeometry, coneMaterial);
      cone.rotation.x = Math.PI / 2;
      cone.position.set(0, 0.5, 1);
      body.add(cone);

      scene.add(body);
      playerMeshes[p.id] = { mesh: body, data: p };

      // Draw route
      if (p.route && p.route.length > 1) {
        const routePoints = p.route.map(([x, z]) => new THREE.Vector3(x, 0.5, z));
        const curve = new THREE.CatmullRomCurve3(routePoints);
        const tubeGeometry = new THREE.TubeGeometry(curve, 32, 0.1, 8, false);
        const tubeMaterial = new THREE.MeshBasicMaterial({
          color: 0x60a5fa,
          opacity: 0.6,
          transparent: true,
        });
        const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
        scene.add(tube);
        routeLines.push(tube);
      }
    });

    // Ball
    const ballGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    ballGeometry.scale(1, 0.6, 0.6); // Football shape
    const ballMaterial = new THREE.MeshStandardMaterial({
      color: 0x8b4513,
      roughness: 0.4,
    });
    const ball = new THREE.Mesh(ballGeometry, ballMaterial);
    ball.castShadow = true;
    ball.position.set(0, 2.5, -5);
    scene.add(ball);

    // Camera presets
    const cameraPresets = {
      broadcast: { pos: [35, 25, 45], target: [0, 0, 10] },
      endzone: { pos: [0, 8, -25], target: [0, 0, 15] },
      overhead: { pos: [0, 60, 10], target: [0, 0, 10] },
      sideline: { pos: [50, 8, 5], target: [0, 0, 5] },
      dynamic: null, // Handled in animation
    };

    let currentCamera = 'broadcast';
    let isDynamicCamera = false;

    // Camera button handlers
    document.querySelectorAll('.camera-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.camera-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        const preset = btn.dataset.camera;
        currentCamera = preset;
        isDynamicCamera = preset === 'dynamic';

        if (!isDynamicCamera && cameraPresets[preset]) {
          const { pos, target } = cameraPresets[preset];
          animateCamera(pos, target);
        }
      });
    });

    function animateCamera(pos, target, duration = 1000) {
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const endPos = new THREE.Vector3(...pos);
      const endTarget = new THREE.Vector3(...target);
      const startTime = Date.now();

      function update() {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

        camera.position.lerpVectors(startPos, endPos, ease);
        controls.target.lerpVectors(startTarget, endTarget, ease);

        if (t < 1) requestAnimationFrame(update);
      }
      update();
    }

    // Animation
    let time = 0;
    let ballInFlight = false;
    let ballFlightStart = 0;
    let ballTarget = null;

    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      document.getElementById('time').textContent = time.toFixed(1) + 's';

      // Animate receivers along routes
      playersData.forEach(p => {
        if (!p.route || p.route.length < 2) return;

        const mesh = playerMeshes[p.id].mesh;
        const progress = (Math.sin(time * 0.5) + 1) / 2;

        const routeLen = p.route.length - 1;
        const idx = Math.floor(progress * routeLen);
        const t = (progress * routeLen) - idx;

        const p1 = p.route[Math.min(idx, routeLen)];
        const p2 = p.route[Math.min(idx + 1, routeLen)];

        mesh.position.x = p1[0] + (p2[0] - p1[0]) * t;
        mesh.position.z = p1[1] + (p2[1] - p1[1]) * t;

        // Face direction of movement
        const angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
        mesh.rotation.y = angle;
      });

      // Simulate ball throw every 4 seconds
      if (Math.floor(time) % 4 === 2 && !ballInFlight) {
        ballInFlight = true;
        ballFlightStart = time;
        ballTarget = playersData.find(p => p.id === 'wr1');
      }

      if (ballInFlight && ballTarget) {
        const flightDuration = 1.5;
        const progress = (time - ballFlightStart) / flightDuration;

        if (progress >= 1) {
          ballInFlight = false;
          ball.position.set(0, 2.5, -5); // Reset to QB
        } else {
          // Parabolic arc
          const startPos = new THREE.Vector3(0, 2.5, -5);
          const targetMesh = playerMeshes[ballTarget.id].mesh;
          const endPos = new THREE.Vector3(
            targetMesh.position.x,
            2,
            targetMesh.position.z
          );

          ball.position.lerpVectors(startPos, endPos, progress);
          // Add arc
          ball.position.y = 2.5 + Math.sin(progress * Math.PI) * 12;
        }
      }

      // Dynamic camera follows ball
      if (isDynamicCamera) {
        const targetZ = ballInFlight ? ball.position.z : -5;
        camera.position.x = 30;
        camera.position.y = 15 + Math.sin(time * 0.3) * 3;
        camera.position.z = targetZ + 20;
        controls.target.set(0, 0, targetZ);
      }

      controls.update();
      renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
